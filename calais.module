<?php
/*
  Copyright (C) 2008-2010 by Phase2 Technology.
  Author(s): Frank Febbraro, Irakli Nadareishvili

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY. See the LICENSE.txt file for more details.

  $Id: calais.module,v 1.3.2.16.2.22.2.11 2009/12/07 08:33:20 inadarei Exp $
 */
/**
 * @file
 *
 * Had to rename calais_process_node, interfered with hook_process_HOOK
 */

// Request constants
define('CALAIS_REQUEST_NO',     0);
define('CALAIS_REQUEST_MANUAL', 1);
define('CALAIS_REQUEST_AUTO',   2);

// Constants for how to apply tags once retrieved
define('CALAIS_PROCESS_AUTO',       0);
define('CALAIS_PROCESS_AUTO_ONCE',  1);
define('CALAIS_PROCESS_MANUAL',     2);

define('CALAIS_WATCHDOG',           'Calais');

/**
 * Implementation of hook_perm().
 */
function calais_perm() {
  return array(
    'administer calais' => array(
      'title' => t('OpenCalais Node Settings'),
      'description' => t('Administer OpenCalais Node Settings'),
    ),
    'access calais' => array(
      'title' => t('Access OpenCalais Keywords'),
      'description' => t('Access the OpenCalais keywords for a Node'),
    ),
  );
}

/**
 * Implementation of hook_menu().
 */
function calais_menu() {
  $items = array();

  $items['admin/config/calais/calais-node'] = array(
    'title' => 'Calais Node Settings',
    'description' => 'Configurations for OpenCalais Integration with content nodes',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('calais_admin_settings'),
    'access arguments' => array('administer calais'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'calais.admin.inc',
  );



//  $items['admin/settings/calais/bulk-process'] = array(
//    'title' => 'Calais Bulk Processing',
//    'description' => 'Submits all Nodes of a specific type to Calais for processing',
//    'page callback' => 'drupal_get_form',
//    'page arguments' => array('calais_bulk_process'),
//    'access arguments' => array('administer calais'),
//    'weight' => 10,
//    'type' => MENU_LOCAL_TASK
//  );
//
//  $items['admin/settings/calais/bulk-process/clear/%'] = array(
//    'title' => 'Calais Reset Bulk Processing',
//    'description' => 'Clears a continue flag for a particular content type',
//    'page callback' => 'calais_bulk_clear',
//    'page arguments' => array(5),
//    'access arguments' => array('administer calais'),
//    'type' => MENU_CALLBACK
//  );
//
//  $items['node/%node/calais'] = array(
//    'title' => 'Calais',
//    'page callback' => 'drupal_get_form',
//    'page arguments' => array('calais_keywords_form', 1),
//    'access callback' => 'calais_access',
//    'access arguments' => array(1),
//    'weight' => 2,
//    'type' => MENU_LOCAL_TASK
//  );
//
//  $items['node/%/calais/rdf'] = array(
//    'title' => 'Calais',
//    'page callback' => 'calais_get_rdf',
//    'page arguments' => array(1),
//    'access callback' => 'user_access',
//    'access arguments' => array('access calais rdf'),
//    'type' => MENU_CALLBACK
//  );

  return $items;
}

/**
 * Implementation of hook_preprocess_node().
 *
 * If RDF exists for a node, provide an autodiscovery link.
 */
function calais_preprocess_node(&$variables) {
  $node = $variables['node'];
//  $count = rdf_count(NULL, NULL, NULL, calais_rdf_options($node->nid));
//  
  // Add an RDF autodiscovery link when the node is displayed by itself as a page:
//  if (user_access('access calais rdf') && $count) {
//    rdf_add_autodiscovery_link(t('Calais RDF'), url("node/$node->nid/calais/rdf"), 'rdf+xml');
//  }
}

/**
 * Implementation of hook_access().
 */
function calais_access($node) {
  return user_access('access calais') && calais_processing_type($node) != CALAIS_PROCESS_NO;
}

/**
 * Implementation of hook_theme();
 */
function calais_theme() {
  return array(
    'calais_suggestions' => array(
      'arguments' => array('vid', 'terms'),
      'file' => 'calais.ui.inc',
    ),
  );
}

/**
 * Implements hook_node_insert().
 */
function calais_node_insert(&$node) {
  dpm('hook_node_insert');
  calais_handle_node($node);
}

/**
 * Implements hook_node_udpate().
 */
function calais_node_update(&$node) {
  dpm('hook_node_update');
  calais_handle_node($node, TRUE);
}

/**
 * Implements hook_node_delete().
 */
function calais_node_delete(&$node) {
  calais_delete_node($node);
}

/**
 * A node is getting removed so do some cleanup.
 *
 * @param $node The node for deletion
 */
function calais_delete_node($node) {
  db_query("DELETE FROM {calais_term_node} WHERE nid=%d", $node->nid);
}

/**
 * Process the provided node according to the processing type.
 *
 * @param $node 
 *    The node to process
 * @param $update 
 *    Boolean representing if this is an update to a previously created node.
 */
function calais_handle_node(&$node, $update = FALSE) {

  // TODO: Should this node type be processed?  
  $config = (object)calais_get_node_config($node);
  dpm($config);
  $keywords = !empty($config->use_semantic_proxy)
                  ? calais_invoke_semanticproxy($node)
                  : calais_invoke_calais($node);
  dpm($keywords);
  if(empty($keywords))
    return;

  //db_query("DELETE FROM {calais_term_node} WHERE nid=%d", $node->nid);

  //module_invoke_all('calais_preprocess', $node, $keywords);
    
  foreach ($keywords as $cat => $metadata) {
    if (array_key_exists($cat, $config->entities)) {
      $settings = $config->entities[$cat];
      $machine_name = calais_get_vocabulary_mapping($cat);
      $vocab = taxonomy_vocabulary_machine_name_load($machine_name);
      foreach ($metadata->terms as $term) {
        //calais_associate_term($vid, $term, $node);
        if ( ($config->process_type == CALAIS_PROCESS_AUTO || ($config->process_type == CALAIS_PROCESS_AUTO_ONCE && !$update)) 
            && round($term->relevance * 1000) >= round($settings['threshold'] * 1000)) {
          //calais_apply_to_node($vid, $term, $node);
          dpm("Auto applying {$metadata->type} {$term->name} with relevance {$term->relevance}");
        }
      }
    }
  }

  //module_invoke_all('calais_postprocess', $node, $keywords);
}

/**
 * Use the actual Calais Web Service to process this Node's content.
 *
 * @param $node The node to process
 * @return The Calais keywords for this node.
 */
function calais_invoke_calais(&$node) {
  $cloned_node = clone($node);
  node_build_content($cloned_node);
  $body = strip_tags(drupal_render($cloned_node->content));
  $date = format_date($node->created, 'custom', 'r');

  // Allow modification of the content sent to Calais
  drupal_alter("calais_body", $body, $loaded_node);

  if (!is_calais_api_key_set()) {
    $node->calais->service = NULL;
    return array();
  }

  $calais = calais_api_get_service();
  $keywords = $calais->analyzeXML($node->title, $body, $date);
  $node->calais->service = $calais;

  return $keywords;
}

/**
 * Use SemanticProxy to process this Node.
 *
 * @param $node The node to process
 * @return The Calais keywords for this node.
 */
function calais_invoke_semanticproxy(&$node) {
  $key = drupal_strtolower($node->type);
  $spfield = variable_get("calais_semanticproxy_field_{$key}", '');
  
  if(!empty($spfield)) {
    if($spfield == 'calais_feedapi_node') {
      // On insert, $node->feedapi_node is available
      if(isset($node->feedapi_node)) {
        $url = $node->feedapi_node->feed_item->options->original_url;
      }
      else { // On update, we need to pull the URL from the DB. Should always be the same. #feedapifail
        $url = db_result(db_query('SELECT fi.url FROM {feedapi_node_item} fi WHERE fi.nid = %d', $node->nid));
      }
    }
    else {
      // Grab URL from link or textfield 
      $field = $node->{$spfield};
      if(isset($field)) {
       $url = isset($field[0]['url']) ? $field[0]['url'] : $field[0]['value'];
      }
    }
    
    drupal_alter('semanticproxy_url', $url);
    
    $sp = calais_api_get_service(array(), 'semanticproxy');
    $keywords = $sp->analyze($url);
    $node->calais->service = $sp;
    
    if($keywords) {
      // Store the document text if configured
      $docfield = variable_get("calais_semanticproxy_document_{$key}", '');
      if(!empty($docfield) && module_exists('content')) {
        $original_text = $sp->processor->document;
        $node->{$docfield}[0]['value'] = trim($original_text);
        if($node->is_new) {
          content_insert($node);
        }
        else {
          content_update($node);
        }
      }
      return $keywords;
    }
  } 
  
  return array(); 
}

/**
 * Implementation of hook_calais_preprocess().
 *
 * Make sure that a vocabulary exists for all entities returned, if not, create it.
 */
function calais_calais_preprocess(&$node, &$keywords) {
  $mappings = calais_get_vocabulary_mapping();

  foreach ($keywords as $cat => $metadata) {
    // Create a vocabulary if we come across an entity that we dont know of.
    if (!array_key_exists($cat, $mappings)) {
      calais_create_entity_vocabulary($cat);
      drupal_set_message(t('Added a Vocabulary for the new Calais Entity %entity. You may need to update your Calais Node Settings to take advantage of this new entity.', array('%entity' => $cat)));
    }
  }
}

/**
 * Associates a retrieved Calais term with a node.
 *
 * @param $vid  The vocabulary id of the term
 * @param $term The CalaisTerm object
 * @param $node The node for association
 */
function calais_associate_term($vid, &$term, $node) {
  $local_term = calais_get_term($vid, $term);

  $calais_term = $local_term ? $local_term : new CalaisTerm($term->guid, $term->name, $term->relevance);
  // We could array_merge, but defined properties with no value will 
  // overwrite the locals (tid, tdid, etc.), so just be explicit for now.
  $calais_term->vid = $vid; 
  $calais_term->relevance = $term->relevance;
  $calais_term->resolved_guid = $term->resolved_guid;
  $calais_term->resolved_name = $term->resolved_name;
  $calais_term->resolved_type = $term->resolved_type;
  $calais_term->extra = array_merge($calais_term->extra, $term->extra);
  
  calais_save_term($calais_term);
  calais_assign_term_to_node($node->nid, $calais_term);
  $term = $calais_term;
}

/**
 * Find the local Calais Term. First look it up by GUID, if not found, use Vocabulary ID and Name.
 *
 * @param $vid
 *    The Vocabulary ID of the calais term
 * @param $term
 *    The CalaisTerm object to lookup, or a term id
 * @return  
 *    The Calais Term object, false is the term is not found.
 */
function calais_get_term($vid, $term) {
  
  if(is_numeric($term)) {
    $local_term = db_fetch_object(db_query("SELECT * FROM {calais_term} WHERE tid = %d", $term));
  }
  else {
    $local_term = db_fetch_object(db_query("SELECT * FROM {calais_term} WHERE vid = %d AND guid = '%s'", $vid, $term->guid));
    if (!$local_term) {
      // Fall back for older terms with no GUID
      $local_term = db_fetch_object(db_query("SELECT * FROM {calais_term} WHERE vid = %d AND name = '%s'", $vid, $term->name));
    }
  }

  if ($local_term) {
    calais_load_term_extra($local_term);
    return $local_term;    
  }
  
  return FALSE;
}

/**
 * Find the Calais Term by Taxonomy Term Data 
 *
 * @param $term_id
 *    The Term Data ID
 * @return  
 *    The Calais Term object, false is the term is not found.
 */
function calais_get_term_by_taxonomy($term_id) {
  $term = db_fetch_object(db_query("SELECT * FROM {calais_term} WHERE tdid = %d", $term_id));
  if ($term) {
    calais_load_term_extra($term);
    return $term;    
  }
  return FALSE;
}

/**
 * Get the CalaisTerm for the term name and node id. 
 * NOTE: Columns were renamed here so that this object has the same attributes as CalaisTerm for consistency
 *
 * @param $nid The node id to limit the calais term look up
 * @param $term_name The term name to look up
 * @return The Calais Term, or FALSE is it is not found.
 */
function calais_get_node_term_by_name($nid, $term_name) {
  return db_fetch_object(
            db_query("SELECT t.*, tn.relevance
                      FROM {calais_term} t
                      JOIN {calais_term_node} tn ON tn.tid = t.tid
                      WHERE tn.nid = %d and t.name = '%s'", $nid, $term_name));
}

/**
 * Save an existing Calais term
 *
 * @param $term
 *    The CalaisTerm to lookup extra data
 */
function calais_save_term(&$term) {
  if(empty($term->tid)) {
    drupal_write_record('calais_term', $term);        
  }
  else {
    drupal_write_record('calais_term', $term, 'tid');        
  }
  calais_save_term_extra($term);
}

/**
 * Loads the resolved data associated with the supplied Calais Term
 *
 * @param $term
 *    The CalaisTerm to lookup extra data
 */
function calais_load_term_extra(&$term) {
  if(isset($term->resolved_type)) {
    $table = 'calais_term_data_' . $term->resolved_type;
    $data = db_fetch_array(db_query("SELECT * FROM {" . $table . "} WHERE tid = %d", $term->tid));
    $term->extra = $data ? $data : array();
  }
  else {
    $term->extra = array();    
  }
}

/**
 * Saves the resolved data associated with the supplied Calais Term
 *
 * @param $term
 *    The CalaisTerm to lookup extra data
 */
function calais_save_term_extra(&$term) {
  if(isset($term->resolved_type) && !empty($term->extra)) {
    $table = 'calais_term_data_' . $term->resolved_type;
    $data = &$term->extra;
    $data['tid'] = $term->tid;        
    if(isset($data['did'])) {
      drupal_write_record($table, $data, 'did');        
    }
    else {
      drupal_write_record($table, $data);
    }
  }
}


/**
 * Assign a taxonomy term to the node based on the Calais Term. If no relationship
 * exists with the CalaisTerm and the target taxonomy term add it.
 *
 * @param $vid  The vocabulary id of the term
 * @param $term The CalaisTerm object
 * @param $node The node for association
 */
function calais_apply_to_node($vid, &$term, $node) {
  
  if(empty($term->tdid)) {
    $term->tdid = calais_find_taxonomy_term($vid, $term->name);
    if (!$term->tdid) {
      // An existing term was not found, create it
      $tax_term = array('vid' => $vid, 'name' => $term->name);
      taxonomy_save_term($tax_term);
      $term->tdid = $tax_term['tid'];
    }
    calais_save_term($term);
  }  
  calais_assign_taxonomyterm_to_node($node->nid, $node->vid, $term->tdid);
}

/**
 * Find a taxonomy term in the provided vocabulary by name.
 *
 * @param $vid
 *    The vocabulary id for the term to find.
 * @param $term_name
 *    The Term Name to find a matching taxonomy term
 * @return $tid 
 *    Term id from the {term_data} table, or FALSE is one is not found.
 */
function calais_find_taxonomy_term($vid, $term_name) {
  return db_result(db_query("SELECT tid FROM {term_data} WHERE vid = %d AND name = '%s' ORDER BY tid ASC", $vid, $term_name));
}

/**
 * Create the relationship between a Node and Calais term.
 *
 * @param $nid
 *    The node id
 * @param $term
 *    The CalaisTerm
 */
function calais_assign_term_to_node($nid, $term) {
  db_query("DELETE FROM {calais_term_node} where nid = %d and tid = %d", $nid, $term->tid);
  db_query("INSERT INTO {calais_term_node} (nid, tid, relevance) VALUES(%d, %d, %f)", $nid, $term->tid, $term->relevance);
}

/**
 * Create the relationship between a Node and a Taxonomy Term.
 *
 * @param $nid
 *    The Node ID
 * @param $vid
 *    The Node Revision ID
 * @param $tid
 *    The Taxonomy Term ID
 */
function calais_assign_taxonomyterm_to_node($nid, $vid, $tid) {
  db_query("DELETE FROM {term_node} where nid = %d and vid = %d and tid = %d", $nid, $vid, $tid);
  db_query("INSERT INTO {term_node} (nid, vid, tid) VALUES(%d, %d, %d)", $nid, $vid, $tid);
}

/**
 * Implementation of hook_taxonomy();
 *
 * Process the delete of taxonomy terms to make sure the proper cleanup 
 * happens to Calais Terms that reference them.
 */
function calais_taxonomy($op, $type, $data) {
  if ($type == 'term' && $op == 'delete') {
    db_query("UPDATE {calais_term} SET tdid = NULL WHERE tdid = %d", $data['tid']);
  }
}


/**
 * Returns the Calais vocabularies that are enabled for this node type.
 * <p>Compare to: calais_api_get_all_entities() which gives entityname/vid pairs.
 * Vocabulary names can be updated by users. Entity names stay as defined
 * by Calais.
 *
 * @param $node_type The node type
 *
 * @return Array of vocabularies keyed on vid;
 */
function calais_get_vocabularies($type = NULL) {

  $vocs = calais_get_entity_vocabularies($type);
  
  if(empty($vocs))
    return array();
  
  $pattern = implode(",", $vocs);

  if ($type) {

    $result = db_query("SELECT v.vid, v.*, n.type
                        FROM {vocabulary} v
                        LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid
                        WHERE n.type = '%s' and v.vid in (%s)
                        ORDER BY v.weight, v.name",
      $type, $pattern);
  }
  else {
    $result = db_query('SELECT v.*
                        FROM {vocabulary} v
                        WHERE v.vid in (%s)
                        ORDER BY v.weight, v.name',
      $pattern);
  }

  $vocabularies = array();
  $node_types = array();
  while ($voc = db_fetch_object($result)) {

    // If no node types are associated with a vocabulary, the LEFT JOIN will
    // return a NULL value for type.
    if (isset($voc->type)) {
      $node_types[$voc->vid][$voc->type] = $voc->type;
      unset($voc->type);
      $voc->nodes = $node_types[$voc->vid];
    }
    elseif (!isset($voc->nodes)) {
      $voc->nodes = array();
    }
    $vocabularies[$voc->vid] = $voc;
  }

  return $vocabularies;
}

/**
 * Returns a map of suggested terms for a given vocabulary id. This will return
 * suggested terms for all vocabularies if no vid is specified.
 *
 * @param $nid The node id to get the calais keywords
 * @param $type The node type
 * @param $vid Optional, a specific vocabulary id to return terms
 * @param $threshold 
 *    Optional, A relevance threshold for suggestions. If not specified the default for the node type will be used.
 *
 * @return Array { $vid => array(termObj1, termObj2, termObj3) }
 */
function calais_get_keywords($nid, $type, $vid = NULL, $threshold = NULL) {
  $terms = array();

  if(!isset($threshold)) {
    $threshold = calais_get_node_threshold(drupal_strtolower($type));
  }

  if ($vid) {
    $res = db_query("SELECT t.*, tn.relevance
                     FROM {calais_term} t
                     JOIN {calais_term_node} tn ON tn.tid = t.tid
                     WHERE tn.nid = %d and t.vid = %d and tn.relevance >= %f
                     ORDER BY relevance DESC ", $nid, $vid, $threshold);
    $terms[$vid] = array();
    while ($obj = db_fetch_object($res)) {
      $terms[$vid][] = $obj;
    }
  }
  else {
    $vocabularies = calais_get_entity_vocabularies();
    foreach ($vocabularies as $vid) {
      $keys = calais_get_keywords($nid, $type, $vid, $threshold);
      $terms[$vid] = $keys[$vid];
    }
  }

  return $terms;
}

/**
 * If an entity name is provided it will return the mapping from a Calais entity 
 * to Vocabulary machine name, otherwise it will return all mappings;
 */
function calais_get_vocabulary_mapping($entity = NULL) {
  $mapping = variable_get('calais_vocabulary_mapping', array());
  return isset($entity) ? $mapping[$entity] : $mapping;
}


/**
 * Creates a new vocabulary for the supplied Calais entity name and add it to the mapping.
 */
function calais_create_entity_vocabulary($entity) {
  $readable = calais_api_make_readable($entity);
  $vocab = (object) array(
    'name'         => $readable,
    'machine_name' => calais_api_make_machine($entity),
    'description'  => t("Vocabulary mapping to @name Calais Entity", array('@name' => $readable)),
    'module'       => 'calais',
  );
  
  taxonomy_vocabulary_save($vocab);
  $mapping = variable_get('calais_vocabulary_mapping', array());
  $mapping[$entity] = $vocab->machine_name;
  variable_set('calais_vocabulary_mapping', $mapping);
}

/**
 * Returns the configuration for the provided node.
 */
function calais_get_node_config($node) {
  $type = $node->type;
  
  $config = _calais_default_config($type);
  
  if (!isset($config->entities)) {
    // Load entities from default/global;
  }
  return $config;
}

function _calais_default_config($type) {
  return array(
    'type' => $type,
    'request_type' => CALAIS_REQUEST_AUTO,
    'process_type' => CALAIS_PROCESS_AUTO,
    'use_semantic_proxy' => FALSE,
    'entities' => array(
      'City' => array(
        'threshold' => 0.5,
      ),
      'Company' => array(
        'threshold' => 0.5,
      ),
      'Continent' => array(
        'threshold' => 0.5,
      ),
      'Country' => array(
        'threshold' => 0.5,
      ),
      'Organization' => array(
        'threshold' => 0.5,
      ),
      'Person' => array(
        'threshold' => 0.5,
      ),
      'ProvinceOrState' => array(
        'threshold' => 0.5,
      ),
      'SocialTags' => array(
        'threshold' => 0.5,
      ), 
    ),
  );
}


/**
 * Implementation of hook_semanticproxy_url_alter().
 *
 * SemanticProxy obeys robots.txt and as such will not follow redirects, etc. For example,
 * RSS feeds for Google News Search will send you through Google News to redirect to the real source.
 * SemanticProxy will give a <em>Content Permissions Validator Exception</em> and not follow the 
 * link b/c Google's robots.txt disallows following /news.  We try to strip those out.
 *
 * TODO: Make this URL extraction configurable via admin ui, if possible
 *
 * @param $url 
 *    The URL to alter.
 */
function calais_semanticproxy_url_alter(&$url) {
  $host = parse_url($url, PHP_URL_HOST);

  // Google's robot.txt disallows the follow by bots, so lets extract the real source
  if ($host == 'news.google.com') {
    $querystring = parse_url($url, PHP_URL_QUERY);

    // Split on &, but not if the & is in an html entity. This is a better impl of parse_str().
    $args = preg_split('|&(?!.[a-z0-9]{1,6}+;)|ims', $querystring);
    if(!is_array($args)) {
      return;
    }

    // Process query string args, find the 'url' arg and return the value if it's a valid URL
    foreach($args as $arg) {
      list($key, $val) = explode('=', $arg, 2);
      if ($key == 'url') {
        $val = urldecode($val);
        if(valid_url($val, TRUE)) {
          $url = $val;
          return;
        }
      }
    }
  }
}


/**
 * Implementation of hook_views_api().
 */
function calais_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'calais') .'/views',
  );
}


function ____debug($array, $exit = TRUE) {
  echo "<pre>". print_r($array, TRUE) ."</pre>";

  if ($exit)
    exit(0);
}

